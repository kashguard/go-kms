# KMS 项目开发规范

## 项目概述

这是一个基于 go-starter 框架开发的 KMS（密钥管理服务）系统，参考 HashiCorp Vault 的架构理念和 AWS KMS 的功能特性。系统提供密钥的全生命周期管理、加密解密服务、访问控制和审计功能。

**核心设计原则**：
1. **密钥安全**：密钥在 HSM 内生成和存储，密钥永不离开 HSM 未加密状态
2. **存储抽象**：支持多种存储后端（PostgreSQL、Consul、文件系统等）
3. **认证抽象**：支持多种认证方式（Token、AppRole、LDAP、OAuth 等）
4. **策略引擎**：基于策略的访问控制（Policy-Based Access Control）
5. **审计追踪**：所有操作记录不可篡改的审计日志
6. **零信任架构**：不信任任何请求，所有请求都需要验证

## 架构规范

### 分层架构

严格遵循 go-starter 的分层架构：

```
API Layer (internal/api/handlers/kms/)
  ↓
Service Layer (internal/kms/)
  ├── key/          # 密钥管理
  ├── encryption/   # 加密解密服务
  ├── policy/       # 策略引擎
  ├── audit/        # 审计日志
  └── auth/         # 认证授权
  ↓
Model Layer (internal/models/) - SQLBoiler 生成
  ↓
Persistence Layer (internal/persistence/)
  ├── Metadata Store (PostgreSQL/Consul)
  └── HSM Adapter (PKCS#11)
```

### Wire 依赖注入

**必须遵循 Wire 规范**：

1. **Provider 函数**：所有服务必须提供 Provider 函数
   ```go
   // ✅ 正确
   func NewKeyService(db *sql.DB, hsmAdapter hsm.Adapter, metadataStore storage.MetadataStore) (*Service, error) {
       return &Service{db: db, hsmAdapter: hsmAdapter, metadataStore: metadataStore}, nil
   }
   
   // ❌ 错误 - 不要使用 Init 方法
   func (s *Server) InitKMS() error { ... }
   ```

2. **Wire 配置**：在 `internal/api/wire.go` 中注册所有 Provider
   ```go
   var kmsServiceSet = wire.NewSet(
       key.NewService,
       encryption.NewService,
       policy.NewEngine,
       audit.NewLogger,
       auth.NewService,
       // ...
   )
   ```

3. **Server 结构体**：在 `internal/api/server.go` 中声明服务字段
   ```go
   type Server struct {
       // ...
       KMS *kms.Service `wire:"-"`
       KeyService *key.Service `wire:"-"`
       EncryptionService *encryption.Service `wire:"-"`
       PolicyEngine *policy.Engine `wire:"-"`
       AuditLogger *audit.Logger `wire:"-"`
   }
   ```

4. **跳过 Wire**：使用 `wire:"-"` 标记需要手动初始化的组件（如 Echo、Router）

## 目录结构规范

### KMS 模块结构

```
internal/kms/
├── key/                          # 密钥管理模块
│   ├── service.go                # KeyService 主服务
│   ├── manager.go                # 密钥生命周期管理
│   ├── rotation.go               # 密钥轮换
│   └── types.go
├── encryption/                   # 加密解密服务
│   ├── service.go                # EncryptionService
│   ├── encrypt.go                # 数据加密
│   ├── decrypt.go                # 数据解密
│   ├── datakey.go                # 数据密钥生成（信封加密）
│   └── types.go
├── sign/                         # 签名验证服务
│   ├── service.go                # SignService
│   ├── sign.go                   # 数字签名
│   ├── verify.go                 # 签名验证
│   └── types.go
├── policy/                       # 策略引擎
│   ├── engine.go                 # PolicyEngine
│   ├── evaluator.go              # 策略评估
│   ├── parser.go                 # 策略解析
│   └── types.go
├── audit/                        # 审计日志
│   ├── logger.go                 # AuditLogger
│   ├── storage.go                # 日志存储
│   └── types.go
├── auth/                         # 认证授权
│   ├── service.go                # AuthService
│   ├── token.go                  # Token 认证
│   ├── approle.go                # AppRole 认证
│   ├── ldap.go                   # LDAP 认证
│   └── types.go
├── storage/                      # 存储抽象层
│   ├── interface.go              # 存储接口定义
│   ├── postgresql.go             # PostgreSQL 实现
│   ├── consul.go                 # Consul 实现
│   ├── filesystem.go             # 文件系统实现
│   └── types.go
├── hsm/                          # HSM 适配器
│   ├── adapter.go                # HSMAdapter 接口
│   ├── pkcs11.go                 # PKCS#11 实现
│   ├── software.go               # 软件 HSM（开发测试）
│   └── types.go
└── types.go
```

### API Handlers 结构

```
internal/api/handlers/kms/
├── keys/
│   ├── post_create_key.go        # POST /v1/keys
│   ├── get_key.go                # GET /v1/keys/{key_id}
│   ├── put_update_key.go         # PUT /v1/keys/{key_id}
│   ├── delete_key.go             # DELETE /v1/keys/{key_id}
│   ├── post_enable_key.go        # POST /v1/keys/{key_id}/enable
│   ├── post_disable_key.go       # POST /v1/keys/{key_id}/disable
│   ├── post_rotate_key.go        # POST /v1/keys/{key_id}/rotate
│   └── get_list_keys.go          # GET /v1/keys
├── encryption/
│   ├── post_encrypt.go           # POST /v1/encrypt
│   ├── post_decrypt.go           # POST /v1/decrypt
│   └── post_generate_data_key.go # POST /v1/generate-data-key
├── sign/
│   ├── post_sign.go              # POST /v1/sign
│   └── post_verify.go            # POST /v1/verify
├── policies/
│   ├── post_create_policy.go     # POST /v1/policies
│   ├── get_policy.go             # GET /v1/policies/{policy_id}
│   ├── put_update_policy.go      # PUT /v1/policies/{policy_id}
│   └── delete_policy.go          # DELETE /v1/policies/{policy_id}
└── audit/
    ├── get_audit_logs.go         # GET /v1/audit-logs
    └── post_export_audit_logs.go # POST /v1/audit-logs/export
```

**命名规范**：
- Handler 文件：`{method}_{route_name}.go`（如 `post_create_wallet.go`）
- Handler 函数：`{method}{RouteName}Handler`（如 `postCreateWalletHandler`）
- Route 函数：`{Method}{RouteName}Route`（如 `PostCreateWalletRoute`）

## 编码规范

### Go 代码规范

1. **遵循 Go 标准**：使用 `gofmt`、`golint`、`golangci-lint`
2. **错误处理**：始终检查错误，使用 `errors.Wrap` 或 `fmt.Errorf` 添加上下文
3. **上下文传递**：所有服务方法第一个参数必须是 `context.Context`
4. **接口定义**：接口定义在服务包内，使用小写接口名（如 `service`），实现使用大写（如 `Service`）

### 命名规范

**包名**：
- 使用小写、简短、有意义的名称
- 避免下划线和混合大小写
- 示例：`kms`, `key`, `encryption`, `policy`, `audit`, `hsm`

**类型名**：
- 使用驼峰命名，首字母大写（导出）
- 接口名通常以 `er` 结尾（如 `Adapter`, `Manager`, `Engine`）
- 示例：`KeyService`, `EncryptionService`, `PolicyEngine`, `HSMAdapter`

**函数名**：
- Provider 函数：`New{Type}`（如 `NewWalletService`）
- 服务方法：使用动词开头（如 `CreateWallet`, `GetBalance`）
- 私有函数：小写开头（如 `derivePrivateKey`）

**变量名**：
- 使用驼峰命名
- 简短但有意义
- 避免单字母变量（除了循环变量 `i`, `j`, `k`）

### 错误处理

#### Service 层错误处理

```go
// ✅ 正确 - 使用 errors 包
import "github.com/pkg/errors"

func (s *Service) CreateKey(ctx context.Context, req *CreateKeyRequest) (*KeyMetadata, error) {
    // 业务验证（不是参数验证）
    if req.KeyType != "AES_256" && req.KeyType != "RSA_2048" {
        return nil, ErrInvalidKeyType
    }
    
    // 验证权限
    if err := s.policyEngine.EvaluatePolicy(ctx, req.PolicyID, "create_key"); err != nil {
        return nil, errors.Wrap(err, "policy evaluation failed")
    }
    
    // 在 HSM 内生成密钥
    hsmHandle, err := s.hsmAdapter.GenerateKey(ctx, req.KeySpec)
    if err != nil {
        return nil, errors.Wrap(err, "failed to generate key in HSM")
    }
    
    // 保存密钥元数据
    keyMetadata := &KeyMetadata{
        KeyID: generateKeyID(),
        Alias: req.Alias,
        KeyType: req.KeyType,
        KeyState: KeyStateEnabled,
        HSMHandle: hsmHandle,
    }
    
    if err := s.metadataStore.SaveKeyMetadata(ctx, keyMetadata); err != nil {
        return nil, errors.Wrap(err, "failed to save key metadata")
    }
    
    // 记录审计日志
    s.auditLogger.LogEvent(ctx, &AuditEvent{
        EventType: "KeyCreated",
        KeyID: keyMetadata.KeyID,
        Operation: "create_key",
        Result: "Success",
    })
    
    return keyMetadata, nil
}

// ✅ 正确 - 定义错误变量
var (
    ErrKeyNotFound = errors.New("key not found")
    ErrInvalidKeyType = errors.New("invalid key type")
    ErrInvalidKeyState = errors.New("invalid key state")
    ErrKeyDisabled = errors.New("key is disabled")
    ErrKeyDeleted = errors.New("key is deleted")
    ErrInvalidCiphertext = errors.New("invalid ciphertext")
    ErrInvalidSignature = errors.New("invalid signature")
    ErrPolicyDenied = errors.New("policy denied")
)

// ✅ 正确 - 事务处理
func (s *Service) ProcessWithdraw(ctx context.Context, req *WithdrawRequest) error {
    return s.db.Transaction(func(tx *sql.Tx) error {
        // 原子操作
        if err := s.deductBalance(ctx, tx, req); err != nil {
            return errors.Wrap(err, "failed to deduct balance")
        }
        if err := s.createWithdrawRecord(ctx, tx, req); err != nil {
            return errors.Wrap(err, "failed to create withdraw record")
        }
        return nil
    })
}

// ❌ 错误 - 不要忽略错误
result, _ := someFunction()
```

### 日志规范

使用 `zerolog` 进行日志记录：

```go
import "github.com/rs/zerolog/log"

// ✅ 正确 - 结构化日志
log.Info().
    Str("user_id", userID).
    Str("chain_type", chainType).
    Str("address", address).
    Msg("Wallet created successfully")

// ✅ 正确 - 错误日志
log.Error().
    Err(err).
    Str("operation", "create_wallet").
    Msg("Failed to create wallet")

// ❌ 错误 - 不要使用 fmt.Printf
fmt.Printf("Wallet created: %s\n", address)
```

**日志级别**：
- `log.Debug()`: 详细调试信息
- `log.Info()`: 关键操作、状态变更
- `log.Warn()`: 警告信息、异常情况
- `log.Error()`: 系统错误、交易失败

## 安全规范

### 密钥安全

**绝对禁止**：
- ❌ 在任何日志中记录密钥材料、私钥、密钥句柄
- ❌ 将密钥保存到数据库（只保存元数据）
- ❌ 将密钥保存到文件
- ❌ 在错误消息中暴露敏感信息
- ❌ 密钥离开 HSM 未加密状态

**必须遵守**：
- ✅ 密钥在 HSM 内生成和存储，永不离开 HSM
- ✅ 使用密钥句柄（handle）而不是密钥本身进行操作
- ✅ 所有密钥操作记录审计日志（不记录敏感内容）
- ✅ 密码验证失败不暴露具体原因
- ✅ 使用加密上下文（Encryption Context）防止密钥滥用

```go
// ✅ 正确 - 在 HSM 内生成密钥，只返回句柄
func (s *Service) CreateKey(ctx context.Context, req *CreateKeyRequest) (*KeyMetadata, error) {
    // 在 HSM 内生成密钥，密钥永不离开 HSM
    hsmHandle, err := s.hsmAdapter.GenerateKey(ctx, req.KeySpec)
    if err != nil {
        return nil, errors.Wrap(err, "failed to generate key in HSM")
    }
    
    // 只保存密钥元数据和句柄，不保存密钥本身
    keyMetadata := &KeyMetadata{
        KeyID: generateKeyID(),
        HSMHandle: hsmHandle,  // 只保存句柄
        // ... 其他元数据
    }
    
    return keyMetadata, nil
}

// ✅ 正确 - 使用密钥句柄进行加密操作
func (s *Service) Encrypt(ctx context.Context, req *EncryptRequest) (*EncryptResponse, error) {
    // 获取密钥元数据（包含 HSM 句柄）
    keyMetadata, err := s.metadataStore.GetKeyMetadata(ctx, req.KeyID)
    if err != nil {
        return nil, errors.Wrap(err, "failed to get key metadata")
    }
    
    // 验证加密上下文
    if err := s.validateEncryptionContext(ctx, req.EncryptionContext); err != nil {
        return nil, errors.Wrap(err, "encryption context validation failed")
    }
    
    // 在 HSM 内执行加密，密钥不离开 HSM
    ciphertext, err := s.hsmAdapter.Encrypt(ctx, keyMetadata.HSMHandle, req.Plaintext)
    if err != nil {
        return nil, errors.Wrap(err, "failed to encrypt in HSM")
    }
    
    // 记录审计日志（不记录明文）
    s.auditLogger.LogEvent(ctx, &AuditEvent{
        EventType: "Encrypt",
        KeyID: req.KeyID,
        Operation: "encrypt",
        Result: "Success",
        // 不记录 req.Plaintext
    })
    
    return &EncryptResponse{
        CiphertextBlob: ciphertext,
        KeyID: req.KeyID,
    }, nil
}
```

### 数据库安全

- ✅ 使用参数化查询，防止 SQL 注入
- ✅ 敏感字段加密存储
- ✅ 数据库连接使用 TLS
- ✅ 定期备份 keystore 表

```go
// ✅ 正确 - 参数化查询
rows, err := db.QueryContext(ctx, 
    "SELECT * FROM wallets WHERE user_id = $1 AND chain_type = $2",
    userID, chainType)

// ❌ 错误 - SQL 注入风险
query := fmt.Sprintf("SELECT * FROM wallets WHERE user_id = '%s'", userID)
```

## API 接口定义规范（Swagger-First）

### API 开发流程

**必须遵循 Swagger-First 开发模式**：

1. **定义 API 规范**（第一步）
   - 在 `api/paths/` 中定义路径和参数
   - 在 `api/definitions/` 中定义请求/响应类型
   - 在 `api/config/main.yml` 中添加引用

2. **生成代码**（第二步）
   ```bash
   make swagger  # 根据 API 定义生成 Go 类型文件
   ```

3. **实现 Handler**（第三步）
   - 在生成的类型基础上编写 handler 逻辑
   - 使用生成的类型，不要使用 `map[string]interface{}`

### 复合响应类型定义

**重要**：对于包含多个字段的复合响应，必须定义具体的类型名称：

```yaml
# ❌ 错误：匿名响应对象
responses:
  "200":
    description: Success
    schema:
      type: object
      properties:
        data:
          $ref: "#/definitions/WalletResponse"
        balance:
          $ref: "#/definitions/BalanceResponse"

# ✅ 正确：定义具体类型名称
WalletWithBalanceResponse:
  type: object
  required: [data, balance]
  properties:
    data:
      $ref: "#/definitions/WalletResponse"
    balance:
      $ref: "#/definitions/BalanceResponse"
```

然后在 `api/config/main.yml` 中添加引用：
```yaml
definitions:
  walletWithBalanceResponse:
    $ref: "../definitions/wallet.yml#/definitions/WalletWithBalanceResponse"
```

### 参数验证策略

**根据接口类型选择正确的验证方法**：

```go
// 场景1: 只有请求体 (POST /wallet/create)
var request types.PostCreateWalletPayload
if err := util.BindAndValidateBody(c, &request); err != nil {
    return err
}

// 场景2: 只有路径参数 (GET /wallet/{wallet_id})
params := wallet.NewGetWalletParams()
if err := util.BindAndValidatePathParams(c, &params); err != nil {
    return err
}
walletID := params.WalletID

// 场景3: 只有查询参数 (GET /wallet/deposits?user_id=xxx)
params := wallet.NewGetDepositsParams()
if err := util.BindAndValidateQueryParams(c, &params); err != nil {
    return err
}

// 场景4: 路径+查询参数 (GET /wallet/{wallet_id}/balance?token=USDT)
params := wallet.NewGetWalletBalanceParams()
if err := util.BindAndValidatePathAndQueryParams(c, &params); err != nil {
    return err
}

// 场景5: 复合参数 (路径+请求体等)
params := wallet.NewCreateWithdrawParams()
if err := params.BindRequest(c.Request(), nil); err != nil {
    return err  // 同时验证路径参数和请求体
}
walletID := params.WalletID
request := params.Request
```

### 参数验证分层原则

**重要原则**：
- ✅ **Handler 层**：统一处理所有参数验证和类型转换
- ❌ **Service 层**：不应包含重复的参数验证逻辑（如 `validateRequest`, `validateConfig` 等方法）

```go
// ✅ 正确 - Handler 层验证
func postCreateWalletHandler(s *api.Server) echo.HandlerFunc {
    return func(c echo.Context) error {
        var body types.PostCreateWalletPayload
        if err := util.BindAndValidateBody(c, &body); err != nil {
            return err  // 参数验证在 Handler 层完成
        }
        
        // 直接调用 Service，不再验证
        wallet, err := s.Wallet.CreateWallet(ctx, body.UserID, body.ChainType)
        // ...
    }
}

// ❌ 错误 - Service 层重复验证
func (s *Service) CreateWallet(ctx context.Context, req *CreateWalletRequest) (*Wallet, error) {
    // 不要在这里再次验证 req.UserID、req.ChainType 等
    // 这些应该在 Handler 层已经验证过了
    if err := s.validateRequest(req); err != nil {  // ❌ 不要这样做
        return nil, err
    }
    // ...
}
```

### 返回响应规范

```go
// ✅ 正确 - 使用 util.ValidateAndReturn
response := &types.CreateWalletResponse{
    ID: wallet.ID,
    Address: wallet.Address,
}
return util.ValidateAndReturn(c, http.StatusOK, response)

// ✅ 正确 - 复合响应
response := &types.WalletWithBalanceResponse{
    Data: walletResponse,
    Balance: balanceResponse,
}
return util.ValidateAndReturn(c, http.StatusOK, response)

// ❌ 错误 - 直接使用 c.JSON
return c.JSON(http.StatusOK, response)  // 不要这样做
```

## 数据库规范

### 数据库开发流程

1. **编写 Migration**（第一步）
   - 在 `migrations/` 目录下编写数据库迁移文件
   - 文件名格式：`YYYYMMDDHHMMSS-description.sql`

2. **生成代码**（第二步）
   ```bash
   make sql  # 根据 migrations 生成相应的 Go 文件
   ```

### SQLBoiler 模型

- ✅ 所有模型由 SQLBoiler 自动生成，**不要手动修改**
- ✅ 模型文件在 `internal/models/` 目录
- ✅ 使用模型提供的方法进行数据库操作

```go
// ✅ 正确 - 使用 SQLBoiler 模型
import "allaboutapps.dev/aw/go-starter/internal/models"

key, err := models.Keys(
    models.KeyWhere.KeyID.EQ(keyID),
    models.KeyWhere.KeyState.EQ("Enabled"),
).One(ctx, db)

// ✅ 正确 - 使用模型方法
key := &models.Key{
    KeyID: generateKeyID(),
    Alias: req.Alias,
    KeyType: req.KeyType,
    KeyState: "Enabled",
    HSMHandle: hsmHandle,
}
err := key.Insert(ctx, db, boil.Infer())

// ❌ 错误 - 不要直接写 SQL（除非必要）
rows, err := db.Query("SELECT * FROM wallets WHERE ...")
```

### 数据库迁移

- ✅ 迁移文件在 `migrations/` 目录
- ✅ 文件名格式：`YYYYMMDDHHMMSS-description.sql`
- ✅ 使用 `-- +migrate Up` 和 `-- +migrate Down` 标记

```sql
-- +migrate Up
CREATE TABLE keys (
    key_id VARCHAR(255) PRIMARY KEY,
    alias VARCHAR(255) UNIQUE,
    description TEXT,
    key_type VARCHAR(50) NOT NULL,
    key_state VARCHAR(50) NOT NULL DEFAULT 'Enabled',
    key_spec JSONB,
    hsm_handle VARCHAR(255) NOT NULL,
    policy_id VARCHAR(255),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    deletion_date TIMESTAMPTZ,
    tags JSONB
);

CREATE INDEX idx_keys_alias ON keys(alias);
CREATE INDEX idx_keys_state ON keys(key_state);
CREATE INDEX idx_keys_created_at ON keys(created_at);

CREATE TABLE key_versions (
    key_id VARCHAR(255) NOT NULL,
    version INTEGER NOT NULL,
    hsm_handle VARCHAR(255) NOT NULL,
    is_primary BOOLEAN NOT NULL DEFAULT false,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    PRIMARY KEY (key_id, version),
    FOREIGN KEY (key_id) REFERENCES keys(key_id) ON DELETE CASCADE
);

CREATE TABLE policies (
    policy_id VARCHAR(255) PRIMARY KEY,
    description TEXT,
    policy_document JSONB NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE TABLE audit_logs (
    id BIGSERIAL PRIMARY KEY,
    timestamp TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    event_type VARCHAR(50) NOT NULL,
    user_id VARCHAR(255),
    key_id VARCHAR(255),
    operation VARCHAR(50) NOT NULL,
    result VARCHAR(50) NOT NULL,
    details JSONB,
    ip_address VARCHAR(50)
);

CREATE INDEX idx_audit_timestamp ON audit_logs(timestamp);
CREATE INDEX idx_audit_key_id ON audit_logs(key_id);
CREATE INDEX idx_audit_user_id ON audit_logs(user_id);

-- +migrate Down
DROP INDEX IF EXISTS idx_audit_user_id;
DROP INDEX IF EXISTS idx_audit_key_id;
DROP INDEX IF EXISTS idx_audit_timestamp;
DROP TABLE IF EXISTS audit_logs;
DROP TABLE IF EXISTS policies;
DROP TABLE IF EXISTS key_versions;
DROP INDEX IF EXISTS idx_keys_created_at;
DROP INDEX IF EXISTS idx_keys_state;
DROP INDEX IF EXISTS idx_keys_alias;
DROP TABLE IF EXISTS keys;
```

### 数据库设计原则

1. **表设计**：
   - 使用 UUID 作为主键（`uuid_generate_v4()`）
   - 添加 `created_at` 和 `updated_at` 时间戳
   - 使用外键约束保证数据完整性
   - 添加必要的唯一约束和索引

2. **索引设计**：
   - 为常用查询字段添加索引
   - 为外键字段添加索引
   - 为组合查询添加组合索引

3. **数据类型**：
   - 金额使用 `TEXT` 类型存储（避免精度丢失）
   - 时间使用 `TIMESTAMPTZ` 类型
   - 布尔值使用 `BOOLEAN` 类型
   - 枚举使用 `VARCHAR` 或创建枚举类型

## 服务接口设计

### 服务接口规范

所有服务必须定义接口（在服务包内）：

```go
// internal/kms/key/service.go
package key

type Service interface {
    CreateKey(ctx context.Context, req *CreateKeyRequest) (*KeyMetadata, error)
    GetKey(ctx context.Context, keyID string) (*KeyMetadata, error)
    UpdateKey(ctx context.Context, keyID string, req *UpdateKeyRequest) error
    DeleteKey(ctx context.Context, keyID string) error
    EnableKey(ctx context.Context, keyID string) error
    DisableKey(ctx context.Context, keyID string) error
    RotateKey(ctx context.Context, keyID string) (*KeyMetadata, error)
    ListKeys(ctx context.Context, filter *KeyFilter) ([]*KeyMetadata, error)
}

// 实现
type service struct {
    db *sql.DB
    hsmAdapter hsm.Adapter
    metadataStore storage.MetadataStore
    policyEngine policy.Engine
    auditLogger audit.Logger
}

func NewService(db *sql.DB, hsmAdapter hsm.Adapter, metadataStore storage.MetadataStore, policyEngine policy.Engine, auditLogger audit.Logger) (Service, error) {
    return &service{
        db: db,
        hsmAdapter: hsmAdapter,
        metadataStore: metadataStore,
        policyEngine: policyEngine,
        auditLogger: auditLogger,
    }, nil
}
```

### 方法签名规范

```go
// ✅ 正确 - 第一个参数是 context.Context
func (s *Service) CreateKey(ctx context.Context, req *CreateKeyRequest) (*KeyMetadata, error)

// ✅ 正确 - 返回错误
func (s *Service) Encrypt(ctx context.Context, req *EncryptRequest) (*EncryptResponse, error)

// ❌ 错误 - 缺少 context
func (s *Service) CreateKey(req *CreateKeyRequest) (*KeyMetadata, error)
```

## API Handler 规范

### Handler 文件组织

**每个接口单独一个文件**，参考以下模式：

```
internal/api/handlers/kms/
├── keys/
│   ├── handler.go                # Handler 结构体和 NewHandler 函数
│   ├── post_create_key.go        # POST /v1/keys
│   ├── get_key.go                # GET /v1/keys/{key_id}
│   ├── put_update_key.go         # PUT /v1/keys/{key_id}
│   ├── delete_key.go             # DELETE /v1/keys/{key_id}
│   ├── post_enable_key.go        # POST /v1/keys/{key_id}/enable
│   ├── post_disable_key.go       # POST /v1/keys/{key_id}/disable
│   ├── post_rotate_key.go        # POST /v1/keys/{key_id}/rotate
│   └── get_list_keys.go          # GET /v1/keys
├── encryption/
│   ├── post_encrypt.go           # POST /v1/encrypt
│   ├── post_decrypt.go           # POST /v1/decrypt
│   └── post_generate_data_key.go # POST /v1/generate-data-key
└── sign/
    ├── post_sign.go              # POST /v1/sign
    └── post_verify.go             # POST /v1/verify
```

**命名规范**：
- Handler 文件：`{method}_{resource}.go`（如 `post_create_wallet.go`）
- Handler 函数：`{method}{Resource}Handler`（如 `postCreateWalletHandler`）
- Route 函数：`{Method}{Resource}Route`（如 `PostCreateWalletRoute`）

### Handler 结构

遵循 go-starter 的 handler 模式：

```go
// internal/api/handlers/kms/keys/post_create_key.go
package keys

import (
    "net/http"
    "allaboutapps.dev/aw/go-starter/internal/api"
    "allaboutapps.dev/aw/go-starter/internal/api/httperrors"
    "allaboutapps.dev/aw/go-starter/internal/auth"
    "allaboutapps.dev/aw/go-starter/internal/types"
    "allaboutapps.dev/aw/go-starter/internal/util"
    "github.com/labstack/echo/v4"
)

func PostCreateKeyRoute(s *api.Server) *echo.Route {
    return s.Router.APIV1KMS.POST("/keys", postCreateKeyHandler(s))
}

func postCreateKeyHandler(s *api.Server) echo.HandlerFunc {
    return func(c echo.Context) error {
        ctx := c.Request().Context()
        user := auth.UserFromContext(ctx)
        if user == nil {
            return echo.ErrUnauthorized
        }
        log := util.LogFromContext(ctx)
        
        // 参数验证（Handler 层）
        var body types.PostCreateKeyPayload
        if err := util.BindAndValidateBody(c, &body); err != nil {
            return err
        }
        
        // 调用 Service 层
        req := &key.CreateKeyRequest{
            Alias: body.Alias,
            Description: body.Description,
            KeyType: body.KeyType,
            KeySpec: body.KeySpec,
            PolicyID: body.PolicyID,
            Tags: body.Tags,
        }
        
        keyMetadata, err := s.KeyService.CreateKey(ctx, req)
        if err != nil {
            log.Error().Err(err).Msg("Failed to create key")
            return httperrors.NewHTTPError(http.StatusInternalServerError, types.PublicHTTPErrorTypeGeneric, "Failed to create key")
        }
        
        // 返回响应
        response := keyMetadata.ToTypes()
        return util.ValidateAndReturn(c, http.StatusCreated, response)
    }
}
```

### 角色管理和权限控制

**角色定义**：

```go
// internal/auth/roles.go
package auth

type UserRole string

const (
    RoleAdmin UserRole = "admin"
    RoleUser  UserRole = "user"
)
```

**权限检查模式**：

```go
// ✅ 正确 - 管理员权限检查
func postCreateHotWalletHandler(s *api.Server) echo.HandlerFunc {
    return func(c echo.Context) error {
        ctx := c.Request().Context()
        user := auth.UserFromContext(ctx)
        if user == nil {
            return echo.ErrUnauthorized
        }
        log := util.LogFromContext(ctx)

        // 检查用户是否为管理员
        if user.Role != string(auth.RoleAdmin) {
            log.Warn().
                Str("user_id", user.ID).
                Str("user_role", user.Role).
                Msg("Non-admin user attempted to create hot wallet")
            return httperrors.NewHTTPError(
                http.StatusForbidden,
                types.PublicHTTPErrorTypeGeneric,
                "Only admin users can create hot wallets",
            )
        }
        
        // ... 业务逻辑
    }
}
```

**权限控制清单**：
- ✅ 密钥创建：需要 `keys:create` 权限
- ✅ 密钥删除：需要 `keys:delete` 权限（通常仅 `admin`）
- ✅ 加密操作：需要 `keys:use` 权限
- ✅ 策略管理：需要 `policies:manage` 权限（通常仅 `admin`）
- ✅ 审计日志查询：需要 `audit:read` 权限（通常仅 `admin`）
- ✅ 密钥轮换：需要 `keys:rotate` 权限

### 错误处理规范

**Handler 层错误处理**：

```go
func postCreateKeyHandler(s *api.Server) echo.HandlerFunc {
    return func(c echo.Context) error {
        ctx := c.Request().Context()
        log := util.LogFromContext(ctx)
        
        // 参数验证错误 - 返回 400
        var body types.PostCreateKeyPayload
        if err := util.BindAndValidateBody(c, &body); err != nil {
            return err  // util.BindAndValidateBody 会自动返回 400
        }
        
        // 业务逻辑错误 - 返回具体错误码
        req := &key.CreateKeyRequest{
            Alias: body.Alias,
            KeyType: body.KeyType,
            KeySpec: body.KeySpec,
        }
        
        keyMetadata, err := s.KeyService.CreateKey(ctx, req)
        if err != nil {
            // 根据错误类型返回不同状态码
            if errors.Is(err, key.ErrKeyNotFound) {
                return httperrors.NewHTTPError(http.StatusNotFound, "Key not found")
            }
            if errors.Is(err, key.ErrInvalidKeyType) {
                return httperrors.NewHTTPValidationError(
                    http.StatusBadRequest,
                    "Invalid key type",
                    map[string]string{"key_type": "must be one of: AES_256, RSA_2048, ECC_P256"},
                )
            }
            if errors.Is(err, key.ErrPolicyDenied) {
                return httperrors.NewHTTPError(http.StatusForbidden, "Policy denied")
            }
            
            log.Error().Err(err).Msg("Failed to create key")
            return httperrors.NewHTTPError(http.StatusInternalServerError, "Internal server error")
        }
        
        return util.ValidateAndReturn(c, http.StatusCreated, keyMetadata.ToTypes())
    }
}
```

### 路由注册

在 `internal/api/handlers/handlers.go` 中注册路由：

```go
func AttachAllRoutes(s *api.Server) {
    s.Router.Routes = []*echo.Route{
        // ... 现有路由
        keys.PostCreateKeyRoute(s),
        keys.GetKeyRoute(s),
        keys.PutUpdateKeyRoute(s),
        keys.DeleteKeyRoute(s),
        keys.PostEnableKeyRoute(s),
        keys.PostDisableKeyRoute(s),
        keys.PostRotateKeyRoute(s),
        keys.GetListKeysRoute(s),
        encryption.PostEncryptRoute(s),
        encryption.PostDecryptRoute(s),
        encryption.PostGenerateDataKeyRoute(s),
        sign.PostSignRoute(s),
        sign.PostVerifyRoute(s),
        // ...
    }
}
```

## KMS 模块特定规范

### HSM 适配器

```go
// ✅ 正确 - HSM 适配器接口
type Adapter interface {
    // 密钥操作
    GenerateKey(ctx context.Context, keySpec *KeySpec) (string, error) // 返回密钥句柄
    ImportKey(ctx context.Context, keyMaterial []byte, keySpec *KeySpec) (string, error)
    DeleteKey(ctx context.Context, handle string) error
    
    // 加密操作
    Encrypt(ctx context.Context, handle string, plaintext []byte) ([]byte, error)
    Decrypt(ctx context.Context, handle string, ciphertext []byte) ([]byte, error)
    
    // 签名操作
    Sign(ctx context.Context, handle string, digest []byte) ([]byte, error)
    Verify(ctx context.Context, handle string, digest []byte, signature []byte) (bool, error)
    
    // 密钥属性
    GetKeyAttributes(ctx context.Context, handle string) (*KeyAttributes, error)
}
```

### 密钥生命周期管理

```go
// ✅ 正确 - 密钥状态管理
type KeyState string

const (
    KeyStateEnabled        KeyState = "Enabled"
    KeyStateDisabled       KeyState = "Disabled"
    KeyStatePendingDeletion KeyState = "PendingDeletion"
    KeyStateDeleted        KeyState = "Deleted"
)

// ✅ 正确 - 密钥轮换
func (s *Service) RotateKey(ctx context.Context, keyID string) (*KeyMetadata, error) {
    // 获取当前密钥
    keyMetadata, err := s.metadataStore.GetKeyMetadata(ctx, keyID)
    if err != nil {
        return nil, errors.Wrap(err, "failed to get key metadata")
    }
    
    // 在 HSM 内生成新版本密钥
    newHandle, err := s.hsmAdapter.GenerateKey(ctx, keyMetadata.KeySpec)
    if err != nil {
        return nil, errors.Wrap(err, "failed to generate new key version")
    }
    
    // 创建新版本记录
    newVersion := &KeyVersion{
        KeyID: keyID,
        Version: keyMetadata.LatestVersion + 1,
        HSMHandle: newHandle,
        IsPrimary: true,
    }
    
    // 更新旧版本为非主版本
    if err := s.metadataStore.UpdateKeyVersionPrimary(ctx, keyID, keyMetadata.LatestVersion, false); err != nil {
        return nil, errors.Wrap(err, "failed to update old version")
    }
    
    // 保存新版本
    if err := s.metadataStore.SaveKeyVersion(ctx, newVersion); err != nil {
        return nil, errors.Wrap(err, "failed to save new version")
    }
    
    // 记录审计日志
    s.auditLogger.LogEvent(ctx, &AuditEvent{
        EventType: "KeyRotated",
        KeyID: keyID,
        Operation: "rotate_key",
        Result: "Success",
    })
    
    return keyMetadata, nil
}
```

### 加密上下文验证

```go
// ✅ 正确 - 加密上下文验证
func (s *Service) validateEncryptionContext(ctx context.Context, encryptionContext map[string]string) error {
    // 验证加密上下文格式
    if len(encryptionContext) > 10 {
        return errors.New("encryption context too large")
    }
    
    // 验证键值对格式
    for key, value := range encryptionContext {
        if len(key) > 128 || len(value) > 1024 {
            return errors.New("encryption context key or value too long")
        }
    }
    
    return nil
}
```

### 策略引擎

```go
// ✅ 正确 - 策略评估
func (e *Engine) EvaluatePolicy(ctx context.Context, policyID string, action string) error {
    // 加载策略
    policy, err := e.metadataStore.GetPolicy(ctx, policyID)
    if err != nil {
        return errors.Wrap(err, "failed to get policy")
    }
    
    // 评估策略
    allowed := false
    for _, statement := range policy.Statements {
        if statement.Effect == "Allow" {
            for _, allowedAction := range statement.Actions {
                if allowedAction == action || allowedAction == "*" {
                    allowed = true
                    break
                }
            }
        } else if statement.Effect == "Deny" {
            for _, deniedAction := range statement.Actions {
                if deniedAction == action || deniedAction == "*" {
                    return ErrPolicyDenied
                }
            }
        }
    }
    
    if !allowed {
        return ErrPolicyDenied
    }
    
    return nil
}
```

## 测试规范

### 单元测试

```go
// internal/wallet/service_test.go
package wallet

import (
    "context"
    "testing"
    "allaboutapps.dev/aw/go-starter/internal/test"
)

func TestCreateWallet(t *testing.T) {
    test.WithTestDatabase(t, func(db *sql.DB) {
        ctx := context.Background()
        service := NewService(db, ...)
        
        wallet, err := service.CreateWallet(ctx, "user-123", "evm")
        assert.NoError(t, err)
        assert.NotNil(t, wallet)
        assert.Equal(t, "evm", wallet.ChainType)
    })
}
```

### 集成测试

- 使用 `internal/test` 包的测试工具
- 使用 IntegreSQL 进行数据库隔离测试
- 测试完整的业务流程

## 类型定义规范

### API 类型（Swagger 生成）

**重要**：所有 API 类型通过 Swagger 生成，不要手动创建。

1. **在 `api/definitions/` 中定义类型**：
```yaml
# api/definitions/kms.yml
definitions:
  PostCreateKeyPayload:
    type: object
    required: [key_type]
    properties:
      alias:
        type: string
        example: "my-encryption-key"
      description:
        type: string
        example: "用于生产环境数据加密"
      key_type:
        type: string
        enum: [AES_256, RSA_2048, RSA_4096, ECC_P256, ECC_P384, ECC_P521, Ed25519]
        example: AES_256
      key_spec:
        type: object
        properties:
          algorithm:
            type: string
          key_size:
            type: integer
      tags:
        type: object
        additionalProperties:
          type: string
  
  CreateKeyResponse:
    type: object
    required: [key_id, key_type, key_state]
    properties:
      key_id:
        type: string
        example: "key-1234567890abcdef"
      alias:
        type: string
        example: "my-encryption-key"
      key_type:
        type: string
        example: "AES_256"
      key_state:
        type: string
        enum: [Enabled, Disabled, PendingDeletion, Deleted]
        example: "Enabled"
      created_at:
        type: string
        format: date-time
      arn:
        type: string
        example: "arn:kms:us-east-1:123456789012:key/key-1234567890abcdef"
```

2. **在 `api/config/main.yml` 中添加引用**：
```yaml
definitions:
  postCreateWalletPayload:
    $ref: "../definitions/wallet.yml#/definitions/PostCreateWalletPayload"
  createWalletResponse:
    $ref: "../definitions/wallet.yml#/definitions/CreateWalletResponse"
```

3. **运行 `make swagger` 生成 Go 类型**：
```bash
make swagger  # 生成 internal/types/wallet/*.go
```

4. **在 Handler 中使用生成的类型**：
```go
// ✅ 正确 - 使用生成的类型
var body types.PostCreateWalletPayload
if err := util.BindAndValidateBody(c, &body); err != nil {
    return err
}

// ❌ 错误 - 不要手动定义 API 类型
type PostCreateWalletPayload struct {
    ChainType string `json:"chain_type"`
}
```

### 服务类型

服务内部类型定义在服务包的 `types.go`：

```go
// internal/kms/key/types.go
package key

// KeyMetadata 服务内部类型
type KeyMetadata struct {
    KeyID         string
    Alias         string
    Description   string
    KeyType       string
    KeyState      KeyState
    KeySpec       *KeySpec
    HSMHandle     string
    PolicyID      string
    CreatedAt     time.Time
    UpdatedAt     time.Time
    DeletionDate  *time.Time
    Tags          map[string]string
}

// ToTypes 转换为 API 类型
func (k *KeyMetadata) ToTypes() *types.CreateKeyResponse {
    return &types.CreateKeyResponse{
        KeyID:      k.KeyID,
        Alias:      k.Alias,
        KeyType:    k.KeyType,
        KeyState:   string(k.KeyState),
        CreatedAt:  k.CreatedAt,
        ARN:        generateARN(k.KeyID),
    }
}
```

## 配置规范

### 全局配置管理

所有钱包相关配置通过环境变量，使用 `internal/config` 包：

```go
// internal/config/server_config.go
type KMS struct {
    StorageBackend string  // 存储后端类型（postgresql, consul, filesystem）
    HSMType        string  // HSM 类型（pkcs11, software, cloudhsm）
    EnableAudit    bool    // 是否启用审计日志（默认 true）
    EnablePolicy   bool    // 是否启用策略引擎（默认 true）
    KeyRotationDays int    // 密钥自动轮换周期（天，0 表示禁用）
}
```

**环境变量**：
- `KMS_STORAGE_BACKEND`: 存储后端类型（默认 `postgresql`）
- `KMS_HSM_TYPE`: HSM 类型（默认 `software`，生产环境使用 `pkcs11`）
- `KMS_ENABLE_AUDIT`: 是否启用审计日志（默认 `true`）
- `KMS_ENABLE_POLICY`: 是否启用策略引擎（默认 `true`）
- `KMS_KEY_ROTATION_DAYS`: 密钥自动轮换周期（默认 `0`，表示禁用）

**安全设计**：
- 默认启用审计日志和策略引擎
- 生产环境必须使用硬件 HSM（`pkcs11`）
- 密钥轮换默认禁用，需要显式配置

**配置使用**：

```go
// cmd/server/kms_init.go
// 初始化存储后端
var metadataStore storage.MetadataStore
switch s.Config.KMS.StorageBackend {
case "postgresql":
    metadataStore = storage.NewPostgreSQLStore(s.DB)
case "consul":
    metadataStore = storage.NewConsulStore(s.ConsulClient)
case "filesystem":
    metadataStore = storage.NewFilesystemStore(s.Config.KMS.StoragePath)
}

// 初始化 HSM 适配器
var hsmAdapter hsm.Adapter
switch s.Config.KMS.HSMType {
case "pkcs11":
    hsmAdapter = hsm.NewPKCS11Adapter(s.Config.KMS.HSMLibrary, s.Config.KMS.HSMSlot, s.Config.KMS.HSMPIN)
case "software":
    hsmAdapter = hsm.NewSoftwareAdapter()
}

// 初始化密钥服务
keyService := key.NewService(s.DB, hsmAdapter, metadataStore, policyEngine, auditLogger)

// 启动密钥自动轮换（如果启用）
if s.Config.KMS.KeyRotationDays > 0 {
    go keyService.StartAutoRotation(ctx, time.Duration(s.Config.KMS.KeyRotationDays)*24*time.Hour)
}
```

## 代码审查检查清单

在提交代码前检查：

- [ ] 遵循 Wire 依赖注入规范
- [ ] 所有服务方法第一个参数是 `context.Context`
- [ ] 错误处理完整，使用 `errors.Wrap` 添加上下文
- [ ] 使用结构化日志（zerolog），不记录敏感信息
- [ ] 私钥使用后立即清除
- [ ] 数据库查询使用参数化查询
- [ ] 使用 SQLBoiler 模型，不直接写 SQL
- [ ] 所有导出函数和类型有注释
- [ ] 通过 `golangci-lint` 检查
- [ ] 单元测试覆盖核心逻辑
- [ ] API Handler 遵循 go-starter 模式
- [ ] 策略权限检查（使用策略引擎评估权限）
- [ ] 全局配置检查（StorageBackend, HSMType, EnableAudit, EnablePolicy）
- [ ] 密钥操作在 HSM 内执行，密钥不离开 HSM
- [ ] 所有密钥操作记录审计日志（不记录敏感内容）
- [ ] 加密上下文验证（防止密钥滥用）
- [ ] 密钥状态流转正确（Enabled → Disabled → PendingDeletion → Deleted）

## 构建和开发流程

### Make 命令

```bash
# 完整构建流程
make build          # 默认构建：sql + swagger + go-build + go-lint
make all            # 完整构建 + 测试

# API 开发
make swagger        # 生成 API 代码（从 api/ 目录生成 internal/types/）
make watch-swagger  # 监听 API 文件变化

# 数据库开发
make sql            # 生成数据库代码（从 migrations/ 生成 internal/models/）
make sql-reset      # 重置开发数据库
make watch-sql      # 监听 SQL 文件变化

# 测试
make test           # 运行测试
make watch-tests    # 监听文件变化运行测试
```

### 开发流程

1. **API 开发流程**：
   - 在 `api/paths/` 和 `api/definitions/` 中定义接口
   - 运行 `make swagger` 生成类型
   - 实现 Handler 逻辑

2. **数据库开发流程**：
   - 在 `migrations/` 中编写迁移文件
   - 运行 `make sql` 生成模型
   - 在 Service 中使用生成的模型

## 常见错误避免

### ❌ 不要这样做

```go
// ❌ 错误 - 密钥保存到变量
keyMaterial := getKeyFromHSM(handle)
s.keyMaterial = keyMaterial  // 不要保存！

// ❌ 错误 - 日志记录密钥句柄或密钥材料
log.Info().Str("hsm_handle", handle).Msg("...")  // 不要记录句柄
log.Info().Str("key_material", hex.EncodeToString(keyMaterial)).Msg("...")  // 不要记录密钥材料

// ❌ 错误 - SQL 注入
query := fmt.Sprintf("SELECT * FROM wallets WHERE user_id = '%s'", userID)

// ❌ 错误 - 忽略错误
result, _ := someFunction()

// ❌ 错误 - 缺少 context
func CreateWallet(userID string) (*Wallet, error)

// ❌ 错误 - 不使用 Wire
func (s *Server) InitWallet() error

// ❌ 错误 - 先写 Handler 再补 API 定义
// 应该先定义 API，再生成代码，最后实现 Handler

// ❌ 错误 - 使用 map[string]interface{} 而不是生成的类型
return c.JSON(http.StatusOK, map[string]interface{}{
    "id": wallet.ID,
    "address": wallet.Address,
})

// ❌ 错误 - Service 层重复验证参数
func (s *Service) CreateWallet(ctx context.Context, req *Request) (*Wallet, error) {
    if req.UserID == "" {  // ❌ 参数验证应该在 Handler 层
        return nil, errors.New("user_id is required")
    }
}

// ❌ 错误 - 直接使用 c.JSON 返回响应
return c.JSON(http.StatusOK, response)  // 应该使用 util.ValidateAndReturn

// ❌ 错误 - 使用字符串字面量而不是常量
if user.Role != "admin" {  // ❌ 应该使用 auth.RoleAdmin
    return err
}

// ❌ 错误 - 归集操作创建 credits 记录
// 归集不应该影响用户余额，只创建 transactions 记录

// ❌ 错误 - 无条件启动自动服务
rebalanceService.StartAutoRebalance(ctx, interval)  // ❌ 应该检查配置
```

### ✅ 应该这样做

```go
// ✅ 正确 - 使用密钥句柄，密钥不离开 HSM
func (s *Service) Encrypt(ctx context.Context, req *EncryptRequest) (*EncryptResponse, error) {
    // 获取密钥元数据（包含 HSM 句柄）
    keyMetadata, err := s.metadataStore.GetKeyMetadata(ctx, req.KeyID)
    if err != nil {
        return nil, err
    }
    
    // 在 HSM 内执行加密，密钥不离开 HSM
    ciphertext, err := s.hsmAdapter.Encrypt(ctx, keyMetadata.HSMHandle, req.Plaintext)
    if err != nil {
        return nil, err
    }
    
    return &EncryptResponse{CiphertextBlob: ciphertext}, nil
}

// ✅ 正确 - 只记录地址
log.Info().Str("address", address).Msg("Wallet created")

// ✅ 正确 - 参数化查询
rows, err := db.QueryContext(ctx, "SELECT * FROM wallets WHERE user_id = $1", userID)

// ✅ 正确 - 检查错误
result, err := someFunction()
if err != nil {
    return errors.Wrap(err, "failed to ...")
}

// ✅ 正确 - 包含 context
func CreateWallet(ctx context.Context, userID string) (*Wallet, error)

// ✅ 正确 - 使用 Wire Provider
func NewWalletService(db *sql.DB) (*Service, error) {
    return &Service{db: db}, nil
}

// ✅ 正确 - API 优先：先定义，再生成，最后实现
// 1. 在 api/definitions/ 中定义类型
// 2. 运行 make swagger 生成代码
// 3. 实现 Handler

// ✅ 正确 - 使用生成的类型
response := &types.CreateWalletResponse{
    ID: wallet.ID,
    Address: wallet.Address,
}
return util.ValidateAndReturn(c, http.StatusOK, response)

// ✅ 正确 - Handler 层验证参数，Service 层只处理业务逻辑
func postCreateWalletHandler(s *api.Server) echo.HandlerFunc {
    var body types.PostCreateWalletPayload
    if err := util.BindAndValidateBody(c, &body); err != nil {
        return err  // 参数验证在 Handler 层
    }
    // Service 层不再验证参数
    wallet, err := s.Wallet.CreateWallet(ctx, body.UserID, body.ChainType)
}

// ✅ 正确 - 使用角色常量
if user.Role != string(auth.RoleAdmin) {
    return httperrors.NewHTTPError(http.StatusForbidden, ...)
}

// ✅ 正确 - 根据配置启动服务
if s.Config.Wallet.EnableAutoRebalance {
    rebalanceService.StartAutoRebalance(ctx, interval)
}

// ✅ 正确 - 归集只创建 transactions 记录
func (s *service) insertCollectTransaction(ctx context.Context, ...) error {
    tx := &models.Transaction{
        Type: models.TransactionTypeCollect,
        // ... 不创建 credits 记录
    }
    return tx.Insert(ctx, s.db, boil.Infer())
}
```

## 业务逻辑规范

### 密钥生命周期管理

**状态管理**：
- **Enabled**: 密钥可用，可以用于加密、解密、签名等操作
- **Disabled**: 密钥禁用，保留用于解密历史数据，但不能用于新操作
- **PendingDeletion**: 计划删除，等待期（默认 30 天）内可以取消删除
- **Deleted**: 已删除，元数据保留用于审计，密钥已从 HSM 删除

**状态流转**：
- Enabled → Disabled（管理员禁用）
- Disabled → Enabled（管理员启用）
- Enabled/Disabled → PendingDeletion（计划删除）
- PendingDeletion → Deleted（等待期后永久删除）

### 密钥轮换流程

**轮换原则**：
- 创建新版本密钥，旧版本保留用于解密历史数据
- 新版本自动成为主版本（Primary），用于新操作
- 支持使用旧版本密钥解密历史数据
- 可以配置自动轮换周期

**轮换流程**：
1. 在 HSM 内生成新版本密钥
2. 创建新版本记录，标记为主版本
3. 更新旧版本为非主版本
4. 记录审计日志

### 加密解密流程

**加密流程**：
1. 验证用户权限（策略引擎）
2. 验证加密上下文（如果提供）
3. 在 HSM 内执行加密操作
4. 返回密文（包含密钥ID和版本信息）
5. 记录审计日志

**解密流程**：
1. 验证用户权限（策略引擎）
2. 验证加密上下文（必须与加密时一致）
3. 从密文中提取密钥ID和版本
4. 在 HSM 内执行解密操作
5. 返回明文
6. 记录审计日志

### 策略引擎

**策略模型**：
- 基于策略的访问控制（Policy-Based Access Control）
- 支持 Allow 和 Deny 两种效果
- 支持细粒度权限控制（create, read, update, delete, use）
- 支持加密上下文条件验证

**策略评估**：
- 拒绝策略优先于允许策略
- 支持策略继承和组合
- 实时策略评估，不缓存策略结果

### 审计日志

**日志内容**：
- 所有密钥操作（创建、使用、删除等）
- 所有访问尝试（成功和失败）
- 操作上下文（IP、用户、时间等）
- 不记录敏感信息（密钥材料、明文等）

**日志存储**：
- 独立存储，不可篡改
- 加密存储
- 长期保存（符合合规要求）
- 支持日志导出和分析

## 参考资料

- [go-starter 文档](https://github.com/allaboutapps/go-starter)
- [Wire 依赖注入](https://github.com/google/wire)
- [SQLBoiler 文档](https://github.com/volatiletech/sqlboiler)
- [Echo 框架文档](https://echo.labstack.com/)
- [HashiCorp Vault 文档](https://www.vaultproject.io/docs)
- [AWS KMS 开发者指南](https://docs.aws.amazon.com/kms/)
- [PKCS#11 标准](https://en.wikipedia.org/wiki/PKCS_11)
- [KMS 产品文档](../KMS产品文档/)

---

**重要提醒**：
- 始终遵循 go-starter 的架构模式
- 安全第一：密钥在 HSM 内生成和存储，永不离开 HSM
- 使用 Wire 进行依赖注入，不要手动初始化
- 所有数据库操作使用 SQLBoiler 模型
- 遵循项目的错误处理和日志规范
- 所有密钥操作记录审计日志（不记录敏感内容）
- 使用策略引擎进行权限控制，不要硬编码权限检查
- 密钥操作使用密钥句柄，不要直接操作密钥材料
- 验证加密上下文，防止密钥滥用

